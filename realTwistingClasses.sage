#Concrete formulas for power serieses associated to C_0:y^2+y=x^3, see arXiv:1501.06082v2 prop. 6.1.4
F2t.<t>=LazyPowerSeriesRing(GF(2));
D=F2t(lambda n: 1 if is_power_of_two(n) else 0);
w=D(t^3);
inv=w/(t^2);
inv.valuation();#Needs to be called at this point for some reason, see https://github.com/sagemath/sage/issues/40750
F2z1z2.<z1,z2>=LazyPowerSeriesRing(GF(2));
z3=z1+z2+(z1^3+z2^3+D(z1^3+z2^3))/(z1^2+z2^2);
gl=inv(z3);

#While most things are implemented lazily, we need to fix a target precision so that we can work in a finitely generated polynomial ring.
targetPrec=32;#should be even!
F.<a>=GF(4);
A=PolynomialRing(F,targetPrec+1,'b',order='invlex');#Can't use InfinitePolynomialRing since it does not support invlex ordering...
At.<t>=LazyPowerSeriesRing(A);
Axyz.<x,y,z>=LazyPowerSeriesRing(A);

#Power serieses defining the standard 3-structure s:
nu=gl(x,y)*gl(x,z)*gl(y,z);
du=x*y*z*gl(x,gl(y,z));
nt=(x*w(y)-y*w(x))*(y*w(z)-z*w(y))*(z*w(x)-x*w(z));
dt=w(x)*w(y)*w(z)*(x*w(y)+x*w(z)+y*w(x)+y*w(z)+z*w(x)+z*w(y));
#s=(dt*nu)/(nt*du).

#Define the power serieses of the generators of F_{3/2}'
sqr=gl(t,t^16); #Correct mod t^(256) since sqrt(-7)=1+4+(2^4), [2^4](t)=[(-2)^4](t)=t^(4^4). For higher precision preplace 1+4 by better approximation of sqr(-7) in the 2-adic integers
prealpha=gl(t,(a*t)^4);# prealpha=1+(-2*zeta), [-2](t)=t^4, zeta(t)=a*t
alpha=prealpha(sqr.revert());
ii=(t+w(t))/(1+t+a*w(t));
jj=a*ii(a^2*t);

g1=alpha(alpha);
g2=(ii(alpha((ii.revert())(alpha.revert()))));
g3=(jj(alpha((jj.revert())(alpha.revert()))));

#Computes the 3-structure associated to a 1-structure:
def cubic(ll):
    return (ll(gl(x,gl(y,z)))*ll(x)*ll(y)*ll(z))/(ll(gl(x,y))*ll(gl(x,z))*ll(gl(y,z)))

#Make the universal real 1-structure, using the approach of N. Kitchloo, G. Laures, "Real Structures and Morava K-Theories", prop. 2.5
ev=(At(lambda n: 0 if (2*n >= (targetPrec+1)) else A.gens()[2*n]))(t^2)-A.gens()[0]+1;
odd=(At(lambda n: 0  if (2*n+1 >= (targetPrec)) else A.gens()[2*n+1]))(t^2);
Ireal=A.ideal(((ev+ev(inv(t)))/(t+inv(t))-odd).polynomial(targetPrec-1).coefficients());
lreal=At(lambda n: 0 if n>targetPrec else (A.gens()[n]).reduce(Ireal))-A.gens()[0]+1;

#We now compute all relations imposed on {b_2,...,b_{targetPrec}} by needing to fulfill the equation in prop. 2.20 in arXiv:2411.16280 mod (x,y,z)^{targetPrec+1}.
#This is done by computing a Groebner basis for the ideal generated by all coefficients of the difference of the lhs and rhs up to this order.
#Actually, since sage does not handle the division defining s well, we multiply the difference by the denominators and then compute up to order targetPrec + (dt*nt*du*nu).valuation().
g=g1;
diff=dt*nu*cubic(lreal)*nt(g(x),g(y),g(z))*du(g(x),g(y),g(z))-dt(g(x),g(y),g(z))*nu(g(x),g(y),g(z))*cubic(g/(g.coefficient(1)*t))*nt*du;
Icubic=A.ideal(diff.polynomial(targetPrec+32).coefficients())#'+32' since the valuation of dt*nu*nt*du is 32
If4=A.ideal([m^4+m for m in [A.gens()[2*(n+1)] for n in range(targetPrec/2)] ]);
I=If4+Icubic;#Can leave out Ireal here since, by N. Kitchloo, G. Laures, "Real Structures and Morava K-Theories", prop. 2.7, the b_{2n} are algebraically independent.
GB=I.groebner_basis();
At(lambda n: lreal.coefficient(n).reduce(GB)).polynomial(targetPrec)